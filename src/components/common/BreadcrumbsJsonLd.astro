---
import { headerData, footerData } from '~/navigation';
import { trimSlash, getCanonical } from '~/utils/permalinks';

type MenuLink = { text?: string; href?: string; links?: MenuLink[] };
type NavNode = {
  text: string;
  href: string;
  path: string;
  isHash: boolean;
  parent?: NavNode;
};

const isExternalLink = (href: string) =>
  href.startsWith('http://') ||
  href.startsWith('https://') ||
  href.startsWith('mailto:') ||
  href.startsWith('tel:') ||
  href.startsWith('javascript:');

const normalizePath = (value = '') => {
  const trimmed = trimSlash(value);
  return '/' + trimmed;
};

const stripQueryHash = (href: string) => href.split('#')[0].split('?')[0];

const nodes: NavNode[] = [];
const nodeByKey = new Map<string, NavNode>();

const addNode = (text: string, href: string, parent?: NavNode) => {
  if (!text || !href || isExternalLink(href)) return;

  const path = normalizePath(stripQueryHash(href));
  const isHash = href.includes('#');
  const key = `${parent?.href ?? 'root'}|${text}|${href}`;

  if (nodeByKey.has(key)) return nodeByKey.get(key);

  const node: NavNode = { text, href, path, isHash, parent };
  nodes.push(node);
  nodeByKey.set(key, node);
  return node;
};

const findGroupHref = (item: MenuLink) => {
  if (item.href) return item.href;
  if (!item.links?.length) return '';

  const withHash = item.links.find((link) => typeof link.href === 'string' && link.href.includes('#'));
  if (withHash?.href) return withHash.href;

  const firstLink = item.links.find((link) => typeof link.href === 'string');
  return firstLink?.href || '';
};

const collect = (items: MenuLink[] = [], parent?: NavNode) => {
  items.forEach((item) => {
    if (!item?.text) {
      if (item?.links?.length) collect(item.links, parent);
      return;
    }

    const href = typeof item.href === 'string' ? item.href : findGroupHref(item);
    const node = href ? addNode(item.text, href, parent) : undefined;
    if (item.links?.length) collect(item.links, node ?? parent);
  });
};

collect(headerData?.links ?? []);
collect(headerData?.actions ?? []);
collect((footerData?.links ?? []).flatMap((group) => group.links ?? []));

const currentPath = normalizePath(Astro.url.pathname);
const candidates = nodes.filter((node) => node.path === currentPath);
const currentNode = candidates.find((node) => !node.isHash) ?? candidates[0];
const homeNode = nodes.find((node) => node.path === '/' && !node.isHash);

const breadcrumbTrail: NavNode[] = [];
if (currentNode) {
  let cursor: NavNode | undefined = currentNode;
  while (cursor) {
    breadcrumbTrail.unshift(cursor);
    cursor = cursor.parent;
  }

  if (homeNode && (!breadcrumbTrail.length || breadcrumbTrail[0].href !== homeNode.href)) {
    breadcrumbTrail.unshift(homeNode);
  }
}

const itemListElement = breadcrumbTrail.map((node, index) => ({
  '@type': 'ListItem',
  position: index + 1,
  name: node.text,
  item: String(getCanonical(node.href)),
}));
---

{
  itemListElement.length > 0 && (
    <script
      type="application/ld+json"
      is:inline
      set:html={JSON.stringify({
        '@context': 'https://schema.org',
        '@type': 'BreadcrumbList',
        itemListElement,
      })}
    />
  )
}
